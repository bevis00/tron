<!DOCTYPE html>
<html>

<head>
<style>
  #info {
    position: absolute;
    top: 0px;
    width: 100%;
    padding: 10px;
    text-align: center;
    color: #ffff00
  }
  body {
    overflow: hidden;
  }
</style>
</head>

<body>

<div id="info"> Inelastic collision
<br>(fire: J)(aim: L)(I and K control to aim)(pick up ball: O)
</div>
<title>Tron game</title>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="move.js"></script>
<script src="fire.js"></script>
<script src="changePlane.js"></script>
<script src="build.js"></script>
<script src="cubemap.js"></script>
<script src="wheel.js"></script>
<script src="stats.js"></script>


<script type="x-shader/x-fragment" id="fragmentShaderDepth">
    uniform sampler2D texture;
    varying vec2 vUV;

    vec4 pack_depth(const in float depth) {

        const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
        const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
        vec4 res = fract(depth * bit_shift);
        res -= res.xxyz * bit_mask;
        return res;

    }

    void main() {

        vec4 pixel = texture2D(texture, vUV);

        if (pixel.a < 0.5) discard;

        gl_FragData[0] = pack_depth(gl_FragCoord.z);

    }
</script>
<script type="x-shader/x-vertex" id="vertexShaderDepth">
    varying vec2 vUV;

    void main() {

        vUV = 1.0 * uv;

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

        gl_Position = projectionMatrix * mvPosition;

    }
</script>

<script>

  var camera, scene, renderer,stats;

  var keyboard = new KeyboardState();

  var raycaster = new THREE.Raycaster();
  var raycasterR = new THREE.Raycaster();
  var raycasterR2 = new THREE.Raycaster();
  var raycasterR3 = new THREE.Raycaster();
  var raycasterR4 = new THREE.Raycaster();
  var raycasterR5 = new THREE.Raycaster();


  var tank, barrel, turret, head;
  var ball, ballLight, bigBall;
  var tankP, avatarBody, v, vP = new THREE.Vector3(1, 0, 0);

  var cameraOffset;
  var upTemp = new THREE.Vector3();

  var go = 0;
  var angle = 0;
  var change = 0;
  var changeX = 0, changeY = 1, changeZ = 0;

  var pickables = [];
  var planes = [];
  var wallPx = [], wallNx = [], wallPy = [], wallNy = [], wallPz = [], wallNz = [];
  var brick1, brick2;

  var intersects, intersectsR, intersectsR2, intersectsR3, intersectsR4, intersectsR5;
  var laser, laserR, laserR2;
  var targetarr = [];

  var curve;
  var dataPoints = [];
  var uu = 0;
  var fireStart = false;
  var fire = true;

  var speed = 0.006;
  var count = 0, cubeCamera1, cubeCamera2, material;


  init();
  animate();

  function init() {

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    //renderer.physicallyCorrectLights = true;

    renderer.toneMapping = THREE.ReinhardToneMapping;


    $("#container").append(renderer.domElement);

    ////////////////////////////////////////////////

    scene = new THREE.Scene();

    var cubeMap = loadCubemap();
    scene.background = cubeMap;

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.z = 50;

    /////////////////////////////////

    for(var i = 0 ; i < 6 ; i++){

      planes[i] = buildPlanes();
      planes[i].name = "plane" + i;
      planes[i].receiveShadow = true;
      pickables.push(planes[i]);
      scene.add(planes[i]);

    }

    planes[0].position.set(75, 0, 0);
    planes[0].rotation.y = Math.PI / 2;

    planes[1].position.set(-75, 0, 0);
    planes[1].rotation.y = -Math.PI / 2;

    planes[2].position.set(0, 75, 0);
    planes[2].rotation.x = -Math.PI / 2;

    planes[3].position.set(0, -75, 0)
    planes[3].rotation.x = Math.PI / 2;

    planes[4].position.set(0, 0, 75);

    planes[5].position.set(0, 0, -75);
    planes[5].rotation.y = Math.PI;

    //////////////////////////////////////////////////////////////////////////////

    buildLight();

    //wheel
    wheelInit();

    //body
    var bodyGeo = new THREE.BoxGeometry (10, 5, 10);
    var bodyTex = THREE.ImageUtils.loadTexture ('images/body_tex.jpg');
    var bodyBump = THREE.ImageUtils.loadTexture ('images/body_tex_bump.jpg');
    var bodyMat = new THREE.MeshPhongMaterial ({color: 0x555555,
      map: bodyTex
      });
    tank = new THREE.Mesh (bodyGeo, bodyMat);

    turret = new THREE.Object3D();

    var barrelGeo = new THREE.CylinderGeometry (1, 1, 10, 32);
    var barrelMat = new THREE.MeshPhongMaterial ({color: 0x000000});
    barrel = new THREE.Mesh (barrelGeo, barrelMat);
    barrel.position.x = 5;
    barrel.rotation.z = -Math.PI/2;

    head = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 32), new THREE.MeshBasicMaterial({color: 0x664c14}));

    turret.add(head, barrel);
    turret.position.y = 10;

    //bottom
    var bottomGeo = new THREE.SphereGeometry (4, 32, 32, 0, Math.PI*2, 0, Math.PI/2);
    var bottomTex ;
    var bottomMat = new THREE.MeshPhongMaterial ({color: 0x000000});
    bottom = new THREE.Mesh (bottomGeo, bottomMat);
    bottom.position.set (0, 2.5, 0);
    tank.add (bottom);

    //handle
    var handleGeo = new THREE.CylinderGeometry (2, 2, 10, 32);
    var handleMat = new THREE.MeshPhongMaterial ({color: 0x000000});
    handle = new THREE.Mesh (handleGeo, handleMat);
    handle.position.set (0, 5, 0);

    handle.rotation.order = 'YXZ';
    handle.rotation.y = -Math.PI/2;
    tank.add (handle);


    tank.add(tire, tire2, turret);
    scene.add(tank);

    ////////////////////////////////////////////////////////////////////////

    cubeCamera1 = new THREE.CubeCamera( 1, 1000, 256 );
    cubeCamera1.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
    scene.add( cubeCamera1 );

    cubeCamera2 = new THREE.CubeCamera( 1, 1000, 256 );
    cubeCamera2.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
    scene.add( cubeCamera2 );

    material = new THREE.MeshPhongMaterial( {
        /*envMap: cubeCamera2.renderTarget.texture*/
    } );

    ////////////////////////////////////////////////////////////////////////

    buildLightBall();
    buildBigBall();

    for(var i = 0 ; i<6 ; i++){
      targetarr[i] = buildTarget();
      scene.add(targetarr[i]);
      targetarr[i].castShadow = true;
    }

    targetarr[0].position.set(-55,myRand(-65,65),myRand(-65,65));
    targetarr[0].rotation.y = Math.PI / 2;
    targetarr[1].position.set(55,myRand(-65,65),myRand(-65,65));
    targetarr[1].rotation.y = -Math.PI / 2;
    targetarr[2].position.set(myRand(-65,65),-55,myRand(-65,65));
    targetarr[2].rotation.x = -Math.PI / 2;
    targetarr[3].position.set(myRand(-65,65),55,myRand(-65,65));
    targetarr[3].rotation.x = Math.PI / 2;
    targetarr[4].position.set(myRand(-65,65),myRand(-65,65),-55);
    targetarr[5].position.set(myRand(-65,65),myRand(-65,65),55);

    /////////////////////////////////////////////////////////////////////////////

    buildWall();
    stats = new Stats();
    document.body.appendChild( stats.dom );

    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);

  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

  }


  function animate() {

    keyboard.update();
    raytest();


    if (keyboard.pressed("W")) {

      go += 3;

      tire.rotation.z -= 0.5;
      tire2.rotation.z -= 0.5;

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.pressed("A")) {

      change += 0.035;

      tire.rotation.z -= 0.2;
      tire2.rotation.z += 0.2;

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.pressed("D")) {

      change += -0.035;

      tire.rotation.z += 0.2;
      tire2.rotation.z -= 0.2;

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.pressed("I")) {

      if(angle < Math.PI / 4){

          angle += 0.015;
          turret.rotation.z = angle;

      }

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.pressed("K")) {

      if(angle > 0){

          angle -= 0.015;
          turret.rotation.z = angle;

      }

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.down("L")) {

      laser = makeLaser();
      laserR = makeLaserR();
      laserR2 = makeLaserR2();

      turret.add(laser);
      scene.add(laserR, laserR2);

    }

    if (keyboard.up("L")) {

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if(tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).x - 1 <= tank.position.x + 8 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).x + 1 >= tank.position.x - 8 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).y - 1 <= tank.position.y + 8 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).y + 1 >= tank.position.y - 8 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).z - 1 <= tank.position.z + 5.7 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).z + 1 >= tank.position.z - 5.7 && fire === false){

      if(ball.visible === true)
        head.material.color = new THREE.Color(0xffff00);

      if (keyboard.down("O")) {

        ball.visible = false;
        fire = true;

      }

      }
      else
        head.material.color = new THREE.Color(0x664c14);

    if(fire){

      if (keyboard.down("J")) {

        ball.castShadow=true;
        ball.position.copy(barrel.localToWorld(new THREE.Vector3(0, 0, 0)));
        ball.visible = true;
        fireMove();
        fireStart = true;
        fire = false;
        dataPoints = [];
        uu = 0;
        speed = 0.006;
        ball.material.color = new THREE.Color(0xff0000);
        ballLight.color = new THREE.Color(0xff0000);

      }

    }

    if(fireStart){

      uu += speed;

      if(uu <= 1)
        ball.position.copy(curve.getPointAt (uu));

      for (var i = 0; i < 362; i++) {

          if (ball.position.z > wallPx[i].position.z - 6 && ball.position.z < wallPx[i].position.z + 6 && ball.position.y > wallPx[i].position.y - 3.6 && ball.position.y < wallPx[i].position.y + 3.6 && ball.position.x > wallPx[i].position.x - 4 && speed > 0.002)
            wallPx[i].visible = false;

         if (ball.position.z > wallNx[i].position.z - 6 && ball.position.z < wallNx[i].position.z + 6 && ball.position.y > wallNx[i].position.y - 3.6 && ball.position.y < wallNx[i].position.y + 3.6 && ball.position.x < wallNx[i].position.x + 4 && speed > 0.002)
            wallNx[i].visible = false;

        if (ball.position.x > wallPy[i].position.x - 6 && ball.position.x < wallPy[i].position.x + 6 && ball.position.z > wallPy[i].position.z - 3.6 && ball.position.z < wallPy[i].position.z + 3.6 && ball.position.y > wallPy[i].position.y - 4 && speed > 0.002)
            wallPy[i].visible = false;

        if (ball.position.x > wallNy[i].position.x - 6 && ball.position.x < wallNy[i].position.x + 6 && ball.position.z > wallNy[i].position.z - 3.6 && ball.position.z < wallNy[i].position.z + 3.6 && ball.position.y < wallNy[i].position.y + 4 && speed > 0.002)
            wallNy[i].visible = false;

        if (ball.position.x > wallPz[i].position.x - 6 && ball.position.x < wallPz[i].position.x + 6 && ball.position.y > wallPz[i].position.y - 3.6 && ball.position.y < wallPz[i].position.y + 3.6 && ball.position.z > wallPz[i].position.z - 4 && speed > 0.002)
            wallPz[i].visible = false;

        if (ball.position.x > wallNz[i].position.x - 6 && ball.position.x < wallNz[i].position.x + 6 && ball.position.y > wallNz[i].position.y - 3.6 && ball.position.y < wallNz[i].position.y + 3.6 && ball.position.z < wallNz[i].position.z + 4 && speed > 0.002)
            wallNz[i].visible = false;

      }

        for (var i = 362; i < 388; i++) {

          if (ball.position.z > wallPx[i].position.z - 3 && ball.position.z < wallPx[i].position.z + 3 && ball.position.y > wallPx[i].position.y - 3.6 && ball.position.y < wallPx[i].position.y + 3.6 && ball.position.x > wallPx[i].position.x - 4)
            wallPx[i].visible = false;

          if (ball.position.z > wallNx[i].position.z - 3 && ball.position.z < wallNx[i].position.z + 3 && ball.position.y > wallNx[i].position.y - 3.6 && ball.position.y < wallNx[i].position.y + 3.6 && ball.position.x < wallNx[i].position.x + 4)
            wallNx[i].visible = false;

          if (ball.position.x > wallPy[i].position.x - 3 && ball.position.x < wallPy[i].position.x + 3 && ball.position.z > wallPy[i].position.z - 3.6 && ball.position.z < wallPy[i].position.z + 3.6 && ball.position.y > wallPy[i].position.y - 4)
            wallPy[i].visible = false;

          if (ball.position.x > wallNy[i].position.x - 3 && ball.position.x < wallNy[i].position.x + 3 && ball.position.z > wallNy[i].position.z - 3.6 && ball.position.z < wallNy[i].position.z + 3.6 && ball.position.y < wallNy[i].position.y + 4)
            wallNy[i].visible = false;

          if (ball.position.x > wallPz[i].position.x - 3 && ball.position.x < wallPz[i].position.x + 3 && ball.position.y > wallPz[i].position.y - 3.6 && ball.position.y < wallPz[i].position.y + 3.6 && ball.position.z > wallPz[i].position.z - 4)
            wallPz[i].visible = false;

          if (ball.position.x > wallNz[i].position.x - 3 && ball.position.x < wallNz[i].position.x + 3 && ball.position.y > wallNz[i].position.y - 3.6 && ball.position.y < wallNz[i].position.y + 3.6 && ball.position.z < wallNz[i].position.z + 4)
            wallNz[i].visible = false;

        }


      if (ball.position.x + 1 >= 75 || ball.position.x - 1 <= -75 || ball.position.y + 1 >= 75 || ball.position.y - 1 < -75 || ball.position.z + 1 > 75 || ball.position.z - 1 < -75)
        if(speed > 0.0015)
          speed -= .0003;

      if(speed < 0.002){

        ball.material.color = new THREE.Color(0x0000ff);
        ballLight.color = new THREE.Color(0x0000ff);

      }


      if(uu > 1){
        console.log(ball.position.distanceTo( new THREE.Vector3(0,0,0) ));
        if(ball.position.distanceTo( new THREE.Vector3(0,0,0) ) < 41  && ball.position.distanceTo( new THREE.Vector3() ) > 39){
          ball.position.copy(tank.localToWorld( new THREE.Vector3(0,0,0) ) );
        }
        dataPoints = [];
        fireStart = false;
        uu = 0;
        speed = 0.006;

      }

    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

    changePlane();
    go = 0;
    change = 0;
    Targeting();
    requestAnimationFrame(animate);
    render();

  }


  function render() {
/*
    bigBall.visible = false;

    if ( count % 2 === 0 ) {
      material.envMap = cubeCamera1.renderTarget.texture;
      cubeCamera2.update( renderer, scene );
    } else {
        material.envMap = cubeCamera2.renderTarget.texture;
        cubeCamera1.update( renderer, scene );
    }

    count ++;

    bigBall.visible = true;
*/    
    stats.update();
    renderer.render(scene, camera);

  }

  function myRand(min,max){

    return  (Math.random()*(max-min+1)+min);

  }

  window.focus();

</script>
</body>

</html>
