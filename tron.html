<!DOCTYPE html>
<html>

<head>
<style>
  #info {
    position: absolute;
    top: 0px;
    width: 100%;
    padding: 10px;
    text-align: center;
    color: #ffff00
  }
  #miniMap {
    border:5px;
    border-style:ridge;
    border-color:red;
    width:200px;height:200px;
    position: absolute;
    bottom: 0px ;
    left:8px;
  }
  body {
    overflow: hidden;
  }
</style>
</head>

<body>

<div id="info"> Inelastic collision
<br>(fire: J)(aim: L)(I and K control to aim)(pick up ball: O)(motion hint: space)
</div>
<title>Tron game</title>
<div id = 'miniMap'></div>

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="move.js"></script>
<script src="fire.js"></script>
<script src="changePlane.js"></script>
<script src="build.js"></script>
<script src="cubemap.js"></script>
<script src="wheel.js"></script>
<script src="stats.js"></script>

<audio id="DiscWars" autoplay loop style="display:none">
<source src="sounds/DiscWars.mp3" type='audio/mpeg'>
</audio>

<audio id="fireSound" style="display:none">
<source src="sounds/fire.mp3" type='audio/mpeg'>
</audio>

<audio id="pickSound" style="display:none">
<source src="sounds/pick.mp3" type='audio/mpeg'>
</audio>

<audio id="flySound" style="display:none">
<source src="sounds/fly.mp3" type='audio/mpeg'>
</audio>


<script type="x-shader/x-fragment" id="fragmentShaderDepth">
    uniform sampler2D texture;
    varying vec2 vUV;

    vec4 pack_depth(const in float depth) {

        const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
        const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
        vec4 res = fract(depth * bit_shift);
        res -= res.xxyz * bit_mask;
        return res;

    }

    void main() {

        vec4 pixel = texture2D(texture, vUV);

        if (pixel.a < 0.5) discard;

        gl_FragData[0] = pack_depth(gl_FragCoord.z);

    }
</script>
<script type="x-shader/x-vertex" id="vertexShaderDepth">
    varying vec2 vUV;

    void main() {

        vUV = 1.0 * uv;

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

        gl_Position = projectionMatrix * mvPosition;

    }
</script>

<script>

  var camera, scene, renderer,stats;
  var camera2, scene2, renderer2;

  var keyboard = new KeyboardState();

  var raycaster = new THREE.Raycaster();
  var raycasterR = new THREE.Raycaster();
  var raycasterR2 = new THREE.Raycaster();
  var raycasterR3 = new THREE.Raycaster();
  var raycasterR4 = new THREE.Raycaster();
  var raycasterR5 = new THREE.Raycaster();


  var tank, barrel, turret, head;
  var ball, ballLight, bigBall;
  var tankP, avatarBody, v, vP = new THREE.Vector3(1, 0, 0);

  var cameraOffset;
  var upTemp = new THREE.Vector3();

  var go = 0;
  var angle = 0;
  var change = 0;
  var changeX = 0, changeY = 1, changeZ = 0;

  var pickables = [];
  var planes = [];
  var wallPx = [], wallNx = [], wallPy = [], wallNy = [], wallPz = [], wallNz = [];
  var brick1, brick2;

  var intersects, intersectsR, intersectsR2, intersectsR3, intersectsR4, intersectsR5;
  var laser, laserR, laserR2;
  var target;

  var curve;
  var dataPoints = [];
  var uu = 0;
  var fireStart = false;
  var fire = true;

  var speed = 0.006;
  var count = 0, cubeCamera1, cubeCamera2, material;

  var miniAvatar = new THREE.Object3D();
  var miniTarget, targetTemp = new THREE.Vector3(), flash = 0, miniBall;
  var hintLine, turn = false;
  var slow = false;
  var fireSound, pickSound, flySound, DiscWars;


  init();
  animate();

  function init() {

    DiscWars = document.getElementById ('DiscWars');
    fireSound = document.getElementById ('fireSound');
    pickSound = document.getElementById ('pickSound');
    flySound = document.getElementById ('flySound');

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    //renderer.physicallyCorrectLights = true;

    renderer.toneMapping = THREE.ReinhardToneMapping;

    //////////////////////////////////////////////////////////////////////////////

    scene = new THREE.Scene();

    var cubeMap = loadCubemap();
    scene.background = cubeMap;

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.z = 50;

    //////////////////////////////////////////////////////////////////////////////

    scene2 = new THREE.Scene();
    scene2.add(new THREE.AxisHelper(25));

    var ww = $("#miniMap").innerWidth();
    var hh = $("#miniMap").innerHeight();
    renderer2 = new THREE.WebGLRenderer();
    renderer2.setSize(ww, hh);
    renderer2.setClearColor(0x888888);
    $("#miniMap").append(renderer2.domElement);

    camera2 = new THREE.PerspectiveCamera(60, ww / hh, 1, 1000);
    camera2.position.set(50, 20, 230);
    camera2.lookAt(new THREE.Vector3(-8, -5, 0));

    var geometry = new THREE.Geometry();
    // add vertices
    geometry.vertices.push(new THREE.Vector3(0, 0, 5));
    geometry.vertices.push(new THREE.Vector3(16, 0, 0));
    geometry.vertices.push(new THREE.Vector3(0, 8, 0));
    geometry.vertices.push(new THREE.Vector3(0, 0, -5));

    // add faces
    geometry.faces.push (new THREE.Face3(0,1,2));
    geometry.faces.push (new THREE.Face3(1,3,2));
    geometry.faces.push (new THREE.Face3(0,1,3));
    geometry.faces.push (new THREE.Face3(0,2,3));


    // build necessary information
    geometry.computeBoundingSphere();
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.DoubleSide, wireframe: true}));
    mesh.position.x = -4;
    miniAvatar.add(mesh);
    scene2.add(miniAvatar);

    buildMiniLinePlanes();

    //////////////////////////////////////////////////////////////////////////////

    for(var i = 0 ; i < 6 ; i++){

      planes[i] = buildPlanes();
      planes[i].name = "plane" + i;
      planes[i].receiveShadow = true;
      pickables.push(planes[i]);
      scene.add(planes[i]);

    }

    planes[0].position.set(300, 0, 0);
    planes[0].rotation.y = Math.PI / 2;

    planes[1].position.set(-300, 0, 0);
    planes[1].rotation.y = -Math.PI / 2;

    planes[2].position.set(0, 300, 0);
    planes[2].rotation.x = -Math.PI / 2;

    planes[3].position.set(0, -300, 0)
    planes[3].rotation.x = Math.PI / 2;

    planes[4].position.set(0, 0, 300);

    planes[5].position.set(0, 0, -300);
    planes[5].rotation.y = Math.PI;

    //////////////////////////////////////////////////////////////////////////////

    buildLight();

    //wheel
    wheelInit();

    //body
    var bodyGeo = new THREE.BoxGeometry (10, 5, 10);
    var bodyTex = THREE.ImageUtils.loadTexture ('images/body_tex.jpg');
    var bodyBump = THREE.ImageUtils.loadTexture ('images/body_tex_bump.jpg');
    var bodyMat = new THREE.MeshPhongMaterial ({color: 0x555555,
      map: bodyTex
      });
    tank = new THREE.Mesh (bodyGeo, bodyMat);

    turret = new THREE.Object3D();

    var barrelGeo = new THREE.CylinderGeometry (1, 1, 10, 32);
    var barrelMat = new THREE.MeshPhongMaterial ({color: 0x000000});
    barrel = new THREE.Mesh (barrelGeo, barrelMat);
    barrel.position.x = 5;
    barrel.rotation.z = -Math.PI/2;

    head = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 32), new THREE.MeshBasicMaterial({color: 0x664c14}));

    turret.add(head, barrel);
    turret.position.y = 10;

    //bottom
    var bottomGeo = new THREE.SphereGeometry (4, 32, 32, 0, Math.PI*2, 0, Math.PI/2);
    var bottomTex ;
    var bottomMat = new THREE.MeshPhongMaterial ({color: 0x000000});
    bottom = new THREE.Mesh (bottomGeo, bottomMat);
    bottom.position.set (0, 2.5, 0);
    tank.add (bottom);

    //handle
    var handleGeo = new THREE.CylinderGeometry (2, 2, 10, 32);
    var handleMat = new THREE.MeshPhongMaterial ({color: 0x000000});
    handle = new THREE.Mesh (handleGeo, handleMat);
    handle.position.set (0, 5, 0);

    handle.rotation.order = 'YXZ';
    handle.rotation.y = -Math.PI/2;
    tank.add (handle);


    tank.add(tire, tire2, turret);
    scene.add(tank);

    ////////////////////////////////////////////////////////////////////////
    /*
    cubeCamera1 = new THREE.CubeCamera( 1, 1000, 256 );
    cubeCamera1.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
    scene.add( cubeCamera1 );

    cubeCamera2 = new THREE.CubeCamera( 1, 1000, 256 );
    cubeCamera2.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
    scene.add( cubeCamera2 );
    */
    material = new THREE.MeshPhongMaterial( {
        transparent: true, opacity: 0.5
    } );

    ////////////////////////////////////////////////////////////////////////

    buildLightBall();
    buildBigBall();

    target = buildTarget();
    scene.add(target);
    target.castShadow = true;
    do{
      target.position.set(myRand(-65,65),myRand(-65,65),myRand(-65,65));
      target.rotation.x=myRand(0,3);
    }while(target.position.distanceTo(new THREE.Vector3(0,0,0))< 47 );

    /////////////////////////////////////////////////////////////////////////////

    miniTarget = buildMiniTarget();
    miniTarget.position.copy(target.position);
    scene2.add(miniTarget);

    /////////////////////////////////////////////////////////////////////////////

    miniBall = buildMiniBall();
    miniBall.position.copy(ball);
    miniBall.visible = false;
    scene2.add(miniBall);

    /////////////////////////////////////////////////////////////////////////////

    buildWall();

    stats = new Stats();
    document.body.appendChild( stats.dom );
    setInterval(blink, 300);

    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);

  }

  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  function blink() {

    turn = !turn;

    if(turn)
      miniTarget.material.color = new THREE.Color(0xff0000);
    else
      miniTarget.material.color = new THREE.Color(0xf49b42);

  }

  function animate() {

    keyboard.update();
    raytest();


    if (keyboard.pressed("W")) {

      go += 3;

      tire.rotation.z -= 0.5;
      tire2.rotation.z -= 0.5;

      turret.remove(laser);
      scene.remove(laserR, laserR2);
      scene.remove(hintLine);

    }

    if (keyboard.pressed("A")) {

      change += 0.035;

      tire.rotation.z -= 0.2;
      tire2.rotation.z += 0.2;

      turret.remove(laser);
      scene.remove(laserR, laserR2);
      scene.remove(hintLine);

    }

    if (keyboard.pressed("D")) {

      change += -0.035;

      tire.rotation.z += 0.2;
      tire2.rotation.z -= 0.2;

      turret.remove(laser);
      scene.remove(laserR, laserR2);
      scene.remove(hintLine);

    }

    if (keyboard.pressed("I")) {

      if(angle < Math.PI / 4){

          angle += 0.015;
          turret.rotation.z = angle;

      }

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.pressed("K")) {

      if(angle > 0){

          angle -= 0.015;
          turret.rotation.z = angle;

      }

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.down("L")) {

      laser = makeLaser();
      laserR = makeLaserR();
      laserR2 = makeLaserR2();

      turret.add(laser);
      scene.add(laserR, laserR2);

    }

    if (keyboard.up("L")) {

      turret.remove(laser);
      scene.remove(laserR, laserR2);

    }

    if (keyboard.down("space")) {

      targetTemp.copy(target.localToWorld(new THREE.Vector3(0, 0, 0)));

      if (changeX === -1 && changeY === 0 && changeZ === 0)
          targetTemp.x = 57;

      if (changeX === 1 && changeY === 0 && changeZ === 0)
          targetTemp.x = -57;

      if (changeX === 0 && changeY === -1 && changeZ === 0)
          targetTemp.y = 57;

      if (changeX === 0 && changeY === 1 && changeZ === 0)
          targetTemp.y = -57;

      if (changeX === 0 && changeY === 0 && changeZ === -1)
          targetTemp.z = 57;

      if (changeX === 0 && changeY === 0 && changeZ === 1)
          targetTemp.z = -57;

      buildHintLine()

    }

    if (keyboard.up("space")) {

      scene.remove(hintLine);

    }

    if(tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).x - 1 <= tank.position.x + 9 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).x + 1 >= tank.position.x - 9 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).y - 1 <= tank.position.y + 9 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).y + 1 >= tank.position.y - 9 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).z - 1 <= tank.position.z + 6.7 && tank.worldToLocal(ball.localToWorld(new THREE.Vector3(0, 0, 0))).z + 1 >= tank.position.z - 6.7 && fire === false){

      if(ball.visible === true)
        head.material.color = new THREE.Color(0xffff00);

      if (keyboard.down("O")) {

        ball.visible = false;
        ball.position.set(0, 0, 0);
        miniBall.visible = false;
        fire = true;
        fireStart = false;
        pickSound.play();

      }

      }
      else
        head.material.color = new THREE.Color(0x664c14);

    if(fire){

      if (keyboard.down("J")) {

        ball.castShadow=true;
        ball.position.copy(barrel.localToWorld(new THREE.Vector3(0, 0, 0)));
        ball.visible = true;
        fireMove();
        fireStart = true;
        fire = false;
        dataPoints = [];
        uu = 0;
        speed = 0.006;
        ball.material.color = new THREE.Color(0xff0000);
        ballLight.color = new THREE.Color(0xff0000);
        fireSound.play();

        miniBall.position.copy(ball.position);
        miniBall.visible = true;

      }

    }

    if(fireStart){

      uu += speed;
      flySound.play();

      if(uu <= 1)
        ball.position.copy(curve.getPointAt (uu));

      for (var i = 0; i < 362; i++) {

          if (ball.position.z > wallPx[i].position.z - 6 && ball.position.z < wallPx[i].position.z + 6 && ball.position.y > wallPx[i].position.y - 3.6 && ball.position.y < wallPx[i].position.y + 3.6 && ball.position.x > wallPx[i].position.x - 4  && ball.position.x < wallPx[i].position.x + 4 && speed > 0.0035 && wallPx[i].visible === true){
            wallPx[i].visible = false;
            slow = true;
          }

          if (ball.position.z > wallNx[i].position.z - 6 && ball.position.z < wallNx[i].position.z + 6 && ball.position.y > wallNx[i].position.y - 3.6 && ball.position.y < wallNx[i].position.y + 3.6 && ball.position.x < wallNx[i].position.x + 4 && ball.position.x > wallNx[i].position.x - 4 && speed > 0.0035 && wallNx[i].visible === true){
            wallNx[i].visible = false;
            slow = true;
          }

          if (ball.position.x > wallPy[i].position.x - 6 && ball.position.x < wallPy[i].position.x + 6 && ball.position.z > wallPy[i].position.z - 3.6 && ball.position.z < wallPy[i].position.z + 3.6 && ball.position.y > wallPy[i].position.y - 4 && ball.position.y < wallPy[i].position.y + 4 && speed > 0.0035 && wallPy[i].visible === true){
            wallPy[i].visible = false;
            slow = true;
          }

          if (ball.position.x > wallNy[i].position.x - 6 && ball.position.x < wallNy[i].position.x + 6 && ball.position.z > wallNy[i].position.z - 3.6 && ball.position.z < wallNy[i].position.z + 3.6 && ball.position.y < wallNy[i].position.y + 4 && ball.position.y > wallNy[i].position.y - 4 && speed > 0.0035 && wallNy[i].visible === true){
            wallNy[i].visible = false;
            slow = true;
          }

          if (ball.position.x > wallPz[i].position.x - 6 && ball.position.x < wallPz[i].position.x + 6 && ball.position.y > wallPz[i].position.y - 3.6 && ball.position.y < wallPz[i].position.y + 3.6 && ball.position.z > wallPz[i].position.z - 4 && ball.position.z < wallPz[i].position.z + 4 && speed > 0.0035 && wallPz[i].visible === true){
            wallPz[i].visible = false;
            slow = true;
          }

          if (ball.position.x > wallNz[i].position.x - 6 && ball.position.x < wallNz[i].position.x + 6 && ball.position.y > wallNz[i].position.y - 3.6 && ball.position.y < wallNz[i].position.y + 3.6 && ball.position.z < wallNz[i].position.z + 4 && ball.position.z > wallNz[i].position.z - 4 && speed > 0.0035 && wallNz[i].visible === true){
            wallNz[i].visible = false;
            slow = true;
          }

      }

      for (var i = 362; i < 388; i++) {

        if (ball.position.z > wallPx[i].position.z - 3 && ball.position.z < wallPx[i].position.z + 3 && ball.position.y > wallPx[i].position.y - 3.6 && ball.position.y < wallPx[i].position.y + 3.6 && ball.position.x > wallPx[i].position.x - 4 && ball.position.x < wallPx[i].position.x + 4 && speed > 0.0035 && wallPx[i].visible === true){
          wallPx[i].visible = false;
          slow = true;
        }

        if (ball.position.z > wallNx[i].position.z - 3 && ball.position.z < wallNx[i].position.z + 3 && ball.position.y > wallNx[i].position.y - 3.6 && ball.position.y < wallNx[i].position.y + 3.6 && ball.position.x < wallNx[i].position.x + 4 && ball.position.x > wallNx[i].position.x - 4 && speed > 0.0035 && wallNx[i].visible === true){
          wallNx[i].visible = false;
          slow = true;
        }

        if (ball.position.x > wallPy[i].position.x - 3 && ball.position.x < wallPy[i].position.x + 3 && ball.position.z > wallPy[i].position.z - 3.6 && ball.position.z < wallPy[i].position.z + 3.6 && ball.position.y > wallPy[i].position.y - 4 && ball.position.y < wallPy[i].position.y + 4 && speed > 0.0035 && wallPy[i].visible === true){
          wallPy[i].visible = false;
          slow = true;
        }

        if (ball.position.x > wallNy[i].position.x - 3 && ball.position.x < wallNy[i].position.x + 3 && ball.position.z > wallNy[i].position.z - 3.6 && ball.position.z < wallNy[i].position.z + 3.6 && ball.position.y < wallNy[i].position.y + 4 && ball.position.y > wallNy[i].position.y - 4 && speed > 0.0035 && wallNy[i].visible === true){
          wallNy[i].visible = false;
          slow = true;
        }

        if (ball.position.x > wallPz[i].position.x - 3 && ball.position.x < wallPz[i].position.x + 3 && ball.position.y > wallPz[i].position.y - 3.6 && ball.position.y < wallPz[i].position.y + 3.6 && ball.position.z > wallPz[i].position.z - 4 && ball.position.z < wallPz[i].position.z + 4 && speed > 0.0035 && wallPz[i].visible === true){
          wallPz[i].visible = false;
          slow = true;
        }

        if (ball.position.x > wallNz[i].position.x - 3 && ball.position.x < wallNz[i].position.x + 3 && ball.position.y > wallNz[i].position.y - 3.6 && ball.position.y < wallNz[i].position.y + 3.6 && ball.position.z < wallNz[i].position.z + 4 && ball.position.z > wallNz[i].position.z - 4 && speed > 0.0035 && wallNz[i].visible === true){
          wallNz[i].visible = false;
          slow = true;
        }

      }

      if( ball.position.distanceTo( new THREE.Vector3(0,0,0) ) < 40 )
        slow = true;


      if (slow)
        if(speed > 0.0029)
          speed -= .0005;

      if(speed < 0.0035){

        ball.material.color = new THREE.Color(0x0000ff);
        ballLight.color = new THREE.Color(0x0000ff);

      }

      if(ball.position.x > 250 || ball.position.y > 250 || ball.position.z > 250 || ball.position.x < -250 || ball.position.y < -250 || ball.position.z < -250){

        var face = Math.floor(Math.random()*6);
        speed = 0;
        ball.material.color = new THREE.Color(0x0000ff);
        ballLight.color = new THREE.Color(0x0000ff);
        fireStart = false;

        if(face === 0){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallPx[face].visible === false);

          ball.position.set(wallPx[face].position.x - 4.4, wallPx[face].position.y, wallPx[face].position.z);

        }

        if(face === 1){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallNx[face].visible === false);

          ball.position.set(wallNx[face].position.x + 4.4, wallNx[face].position.y, wallNx[face].position.z);

        }

        if(face === 2){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallPy[face].visible === false);

          ball.position.set(wallPy[face].position.x, wallPy[face].position.y - 4.4, wallPy[face].position.z);

        }

        if(face === 3){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallNy[face].visible === false);

          ball.position.set(wallNy[face].position.x, wallNy[face].position.y + 4.4, wallNy[face].position.z);

        }

        if(face === 4){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallPz[face].visible === false);

          ball.position.set(wallPz[face].position.x, wallPz[face].position.y, wallPz[face].position.z - 4.4);

        }

        if(face === 5){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallNz[face].visible === false);

          ball.position.set(wallNz[face].position.x, wallNz[face].position.y, wallNz[face].position.z + 4.4);

        }

      }

      if(uu > 1){

        if(ball.position.distanceTo( new THREE.Vector3(0,0,0) ) < 41  && ball.position.distanceTo( new THREE.Vector3() ) > 39){

          var face = Math.floor(Math.random()*6);

          if(face === 0){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallPx[face].visible === false);

          ball.position.set(wallPx[face].position.x - 4.4, wallPx[face].position.y, wallPx[face].position.z);

        }

        if(face === 1){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallNx[face].visible === false);

          ball.position.set(wallNx[face].position.x + 4.4, wallNx[face].position.y, wallNx[face].position.z);

        }

        if(face === 2){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallPy[face].visible === false);

          ball.position.set(wallPy[face].position.x, wallPy[face].position.y - 4.4, wallPy[face].position.z);

        }

        if(face === 3){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallNy[face].visible === false);

          ball.position.set(wallNy[face].position.x, wallNy[face].position.y + 4.4, wallNy[face].position.z);

        }

        if(face === 4){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallPz[face].visible === false);

          ball.position.set(wallPz[face].position.x, wallPz[face].position.y, wallPz[face].position.z - 4.4);

        }

        if(face === 5){

          do{

            face = Math.floor(Math.random()*388);

          }while(wallNz[face].visible === false);

          ball.position.set(wallNz[face].position.x, wallNz[face].position.y, wallNz[face].position.z + 4.4);

        }

        }

        dataPoints = [];
        fireStart = false;
        uu = 0;
        speed = 0.006;

      }

    }

    miniBall.position.copy(ball.position);
    changePlane();
    go = 0;
    change = 0;
    slow = false;
    Targeting();
    requestAnimationFrame(animate);
    render();

  }


  function render() {
/*
    bigBall.visible = false;

    if ( count % 2 === 0 ) {
      material.envMap = cubeCamera1.renderTarget.texture;
      cubeCamera2.update( renderer, scene );
    } else {
        material.envMap = cubeCamera2.renderTarget.texture;
        cubeCamera1.update( renderer, scene );
    }

    count ++;

    bigBall.visible = true;
*/
    stats.update();
    renderer.render(scene, camera);
    renderer2.render(scene2, camera2);

  }

  function myRand(min,max){

    return  (Math.random()*(max-min+1)+min);

  }

  window.focus();

</script>
</body>

</html>
